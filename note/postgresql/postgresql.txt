 编译安装
 cd $postgresql_home
 ./configure --prefix=/03/postgresql
 make
 make install
 

默认端口5432 
pg是多进程模式
pg一个连接建立一个进程
 
 
bin/initdb -D ./data/     				        #初始化数据库
bin/pg_ctl -D ./data/ -l logfile start    #启动实例
bin/postgres -D ./data    				        #实际服务运行的文件

关闭
bin/pg_ctl -D ./data stop
 
bin/pg_ctl -D ./data stop -o SIGTERM  

SIGTERM   
不再允许新的连接，但是允许所有活跃的会话正常完成他们的工作，只有在所有会话都结束任务后才关闭。这是智能关闭。  
  
SIGINT   
不再允许新的连接，向所有活跃服务器发送 SIGTERM(让它们立刻退出)，然后等待所有子进程退出并关闭数据库。这是快速关闭。  
  
SIGQUIT   
令 postgres 向所有子进程发送 SIGQUIT 并且立即退出(所有子进程也会立即退出)，而不会妥善地关闭数据库系统。这是立即关闭。这样做会导致下次启动时的恢复(通过重放 WAL 日志)。推荐只在紧急的时候使用这个方法。  
  
SIGKILL   
此选项尽量不要使用，这样会阻止服务器清理共享内存和信号灯资源，那样的话你只能在启动服务器之前自己手工做这件事。另外，SIGKILL 直接把 postgres 杀掉，而不会等它把信号中继给它的子进程，因此我们还需要手工杀掉每个独立子进程。 
 



bin/psql postgres            #使用初始化创建的数据库postgres

bin/psql postgres user_name  #默认创建的用户名与启动pg服务的系统用户名一致

psql [OPTION]... [DBNAME [USERNAME]]
  -h, --host=HOSTNAME     
  -p, --port=PORT         
  -U, --username=USERNAME 
  -w, --no-password       
  -W, --password          


psql中的命令
\?			###\开始的命令查看
\h			###sql语句查看
\! clear 	###执行系统的命令
\q			###退出命令行 
\db			###列出所有的tablespace	
\l			###列出所有database
\c db_name  ###切换数据库
\dt			###查看数据库下的表
\d tb_name	###查看表的字段 #表结构
\dv			###查看视图
\du			###查看用户    安装时默认以当前用户名创建一个用户，没有密码


schema            #表的全形   schema_name.table_name
tablespace
domains

一个database下有多个schema
不能同时方位不同database下的对象

select * from schema_name.table_name;

系统表
pg_user
pg_roles
pg_tablespace
pg_database
pg_tables

SELECT tablename FROM pg_tables WHERE tablename NOT LIKE 'pg%' AND tablename NOT LIKE 'sql_%' ORDER BY tablename;   ###查询数据库的非系统表

创建表默认在pubic schema下

select * from pg_tables;   #查看表信息 如 schema tablespace

#角色
CREATE ROLE role_name;
DROP ROLE role_name;

#用户
create user test_user with password 'test_password' login in role "TestRole1"     #同时需要修改与重载配置文件pg_hba.conf以允许用户访问
ALTER USER postgres WITH PASSWORD 'postgres';

##进行存储设置？
create tablespace "TestDbs2" location '/u03/postgresql/data/TestDbs2';   		###表空间的文件在数据目录下

##进行命令空间限制？
create schema schema01;					###创建schema  各个对象比如表,函数等存放在各个schema下,同一个schema下不能有重复的对象名字,但在不同schema下可以重复.
grant usage on schema01 to weideguo;



show search_path;			               ###查看创建表时使用的schema
set search_path=schema_name	       ###设置创建表时使用的schema
show all;                          ##查看所有参数
show XXX;      ##查看参数
set XXX=yyyy;  ##设置参数


##进行资源限制？
create database demodb		###创建数据库 一个连接只能来连接一个数据库
template template0
encoding 'UTF8'
tablespace ts_demo01
connection limit 200;

alter database demodb set tablespace ts_demo01;    #更改数据库的表空间

create table table_name(...) tablespace ts_demo; 
 
select pg_relation_filepath('tab100');   ###查看表的位置 



#配置文件#########################################################################################################################
$postgresql/data
postgresql.conf   参数配置文件
pg_hba.conf 		  认证文件，用户登录限制   host-based authentication
pg_ident.conf     配置操作系统用户映射为数据库用户 

####map示例
###################################################pg_hba.conf
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    all             all             192.168.0.0/16          ident map=omicron

###################################################pg_ident.conf
# MAPNAME       SYSTEM-USERNAME         PG-USERNAME
# bryanh can also connect as guest1
omicron         bryanh                  guest1

#########################pg_hba.conf中METHOD的类型
    trust
    
    reject
    
    scram-sha-256
    
    md5
    
    password
    
    gss
    
    sspi
    
    ident
    
    peer
    
    ldap
    
    radius
    
    cert
    
    pam
    
    bsd
       


#配置文件重新加载（二选一）
pg_ctl reload
SELECT pg_reload_conf();
 
 
#####################################################################################################################################  
 
VACUUM
VACUUM — garbage-collect and optionally analyze a database



pg_dump dbname > dumpfile  #备份成sql文件
psql dbname < dumpfile     #恢复

pg_dumpall > dumpfile
psql -f dumpfile postgres

pg_dump -Fc dbname > filename
pg_restore -d dbname filename


归档WAL write ahead log
wal_level         replica or higher, 
archive_mode      on off aways
archive_command   shell command

archive_command = 'test ! -f /mnt/server/archivedir/%f && cp %p /mnt/server/archivedir/%f'  # Unix
archive_command = 'copy "%p" "C:\\server\\archivedir\\%f"'  # Windows

%p is replaced by the path name of the file to archive
%f is replaced by only the file name

PITR
#物理备份(二选一)
pg_basebackup -D /data/pg_backup_test -l 2018_09_13_backup
pg_basebackup -D backup/data -T /opt/ts=$(pwd)/backup/ts    #如果使用表空间使用其他目录，需要指定映射关系

SELECT pg_start_backup('label_name', false, false);   #The third parameter being false  initiate a non-exclusive base backup.
直接复制data目录进行备份
SELECT * FROM pg_stop_backup(false, true);


复制的时候可选不复制以下
pg_wal
pg_replslot
postmaster.pid
postmaster.opts
以下目录下的文件也可以不复制，但目录需要存在
pg_dynshmem 
pg_notify 
pg_serial 
pg_snapshots 
pg_stat_tmp  
pg_subtrans
pgsql_tmp开头的目录可以不复制

#恢复
复制物理备份的文件到对应目录
清空pg_wal，将最新示例的pg_wal下的文件放入，以便恢复到示例down的最后时刻
修改文件recovery.conf（在data目录下）
     restore_command = 'cp /mnt/server/archivedir/%f %p'   #设置从备份的归档wal进行恢复
     recovery_target_timeline(string)                      #设置恢复到的时间点
     recovery_target_time (timestamp)
启动实例

#####################################################################################################################################
